package clients

import (
	"fmt"

	"github.com/tdeslauriers/carapace/pkg/data"
	"github.com/tdeslauriers/carapace/pkg/jwt"
	"github.com/tdeslauriers/carapace/pkg/validate"
	"github.com/tdeslauriers/ran/pkg/authentication"
	"github.com/tdeslauriers/ran/pkg/scopes"
)

const (
	ErrInvalidSlug    = "invalid service client slug"
	ErrInvalidClient  = "invalid service client"
	ErrClientNotFound = "service client not found"

	ErrInvalidOwnerName = "invalid service client owner name"

	ErrClientMissing     = "service client is required to update client scopes: cannot be nil"
	ErrInvalidResourceId = "invalid resource id"
	ErrInvalidCurrentPw  = "invalid current password"
	ErrInvalidNewPw      = "invalid new password"
	ErrInvalidRegisterPw = "invalid registration password"

	ErrInvalidPwMismatch = "new password and confirm password do not match"
	ErrRemoveXref        = " failed to remove client-scope xref record"
	ErrAddXref           = " failed to add client-scope xref record"

	ErrIncorrectPassword = "incorrect password"
)

// service endpoints require s2s-only endpoint scopes
var s2sAllowedRead []string = []string{"r:ran:s2s:clients:*"}

// user endpoints require user endpoint scopes
// NOTE: user-only endpoint scopes will issued to services when they are acting on behalf of a user,
// but in those cases, their must be a user token present in the request ALSO.
var userAllowedRead = []string{"r:ran:clients:*"}
var userAllowedWrite = []string{"w:ran:clients:*"}

// Handler provides http handlers for service client requests
type Handler interface {
	ClientHandler
	RegistrationHandler
	ResetHandler
	ScopesHanlder
}

// NewHandler creates a new service client Handler interface abstracting a concrete implementations
func NewHandler(s Service, scope scopes.Service, s2s, iam jwt.Verifier) Handler {
	return &handler{
		ClientHandler:       NewClientHandler(s, s2s, iam),
		RegistrationHandler: NewRegistrationHandler(s, s2s, iam),
		ResetHandler:        NewResetHandler(s, s2s, iam),
		ScopesHanlder:       NewScopesHandler(s, scope, s2s, iam),
	}
}

var _ Handler = (*handler)(nil)

// handler is a concrete implementation of the Handler interface abstracting smaller interfaces
type handler struct {
	ClientHandler
	RegistrationHandler
	ResetHandler
	ScopesHanlder
}

// Service provides client service operations, it aggregates the ClientService, RegistrationService, and ResetService interfaces
type Service interface {
	ClientService
	RegistrationService
	ResetService
	ClientErrService
}

// NewService creates a new service interface abstracting a concrete implementations of
// the ClientService and ClientErrService interfaces
func NewService(sql data.SqlRepository, creds authentication.CredService) Service {
	return &service{
		ClientService:       NewClientService(sql),
		RegistrationService: NewRegistrationService(sql, creds),
		ResetService:        NewResetService(sql, creds),
		ClientErrService:    NewErrHandlingService(),
	}
}

var _ Service = (*service)(nil)

type service struct {
	ClientService
	RegistrationService
	ResetService
	ClientErrService
}

// ClientRecord is a model for a client record in the database, including password
type ClientRecord struct {
	Id             string          `json:"id,omitempty" db:"uuid"`
	Password       string          `json:"password" db:"password"`
	Name           string          `json:"name" db:"name"`
	Owner          string          `json:"owner" db:"owner"`
	CreatedAt      data.CustomTime `json:"created_at" db:"created_at"`
	Enabled        bool            `json:"enabled" db:"enabled"`
	AccountExpired bool            `json:"account_expired" db:"account_expired"`
	AccountLocked  bool            `json:"account_locked" db:"account_locked"`
	Slug           string          `json:"slug,omitempty" db:"slug"`
}

// RegisterCmd is a model for a client registration request.
// Note: not a db model
type RegisterCmd struct {
	Id              string `json:"id,omitempty"`
	Name            string `json:"name"`
	Owner           string `json:"owner"`
	Password        string `json:"password"`
	ConfirmPassword string `json:"confirm_password"`
	Emabled         bool   `json:"enabled"`
}

// ValidateCmd performs input validation check on client registration fields.
func (r *RegisterCmd) ValidateCmd() error {

	// Id is generated by the service, no validation needed

	// validate name
	if valid, err := validate.IsValidServiceName(r.Name); !valid {
		return fmt.Errorf("%s: %v", ErrInvalidClient, err)
	}

	// validate owner
	if err := validate.IsValidName(r.Owner); err != nil {
		return fmt.Errorf("%s: %v", ErrInvalidOwnerName, err)
	}

	// validate password
	if err := validate.IsValidPassword(r.Password); err != nil {
		return fmt.Errorf("%s: %v", ErrInvalidRegisterPw, err)
	}

	// validate confirm password
	if r.Password != r.ConfirmPassword {
		return fmt.Errorf(ErrInvalidPwMismatch)
	}

	// CreatedAt is a timestamp created programmatically, no validation needed
	// Slug is generated by the service, no validation needed
	// Enabled is a boolean, no validation needed
	// AccountExpired is a boolean, no validation needed
	// AccountLocked is a boolean, no validation needed

	return nil
}

type Client struct {
	Id             string          `json:"id,omitempty" db:"uuid"`
	Name           string          `json:"name" db:"name"`
	Owner          string          `json:"owner" db:"owner"`
	CreatedAt      data.CustomTime `json:"created_at" db:"created_at"`
	Enabled        bool            `json:"enabled" db:"enabled"`
	AccountExpired bool            `json:"account_expired" db:"account_expired"`
	AccountLocked  bool            `json:"account_locked" db:"account_locked"`
	Slug           string          `json:"slug,omitempty" db:"slug"`
}

// ValidateCmd performs input validation check on client fields.
func (c *Client) Validate() error {

	if c.Id != "" && !validate.IsValidUuid(c.Id) {
		return fmt.Errorf("invalid or not well formatted servcice client id")
	}

	if valid, err := validate.IsValidServiceName(c.Name); !valid {
		return fmt.Errorf("invalid service client name: %v", err)
	}

	if err := validate.IsValidName(c.Owner); err != nil {
		return fmt.Errorf("invalid service client owner: %v", err)
	}

	// CreatedAt is a timestamp created programmatically,
	// no validation needed, will be dropped on all updates

	// Enabled is a boolean, no validation needed

	// AccountExpired is a boolean, no validation needed

	// AccountLocked is a boolean, no validation needed

	if c.Slug != "" && !validate.IsValidUuid(c.Slug) {
		return fmt.Errorf("invalid or not well formatted service client slug")
	}

	return nil
}

// Reset is a model for a service client uuid and pw for lookup by reset service
type Reset struct {
	ClientId string `db:"uuid"`
	Password string `db:"password"`
}

// ClientScope is a model for a database join query of a client and its associated scopes
type ClientScope struct {
	ClientId        string          `json:"client_id,omitempty" db:"uuid"`
	ClientName      string          `json:"client_name" db:"name"`
	Owner           string          `json:"owner" db:"owner"`
	ClientCreatedAt data.CustomTime `json:"client_created_at" db:"created_at"`
	Enabled         bool            `json:"enabled" db:"enabled"`
	AccountExpired  bool            `json:"account_expired" db:"account_expired"`
	AccountLocked   bool            `json:"account_locked" db:"account_locked"`
	CLientSlug      string          `json:"client_slug,omitempty" db:"slug"`

	ScopeId        string `db:"scope_id" json:"scope_id,omitempty"`
	ServiceName    string `db:"service_name" json:"service_name"`
	Scope          string `db:"scope" json:"scope"`
	ScopeName      string `db:"scope_name"  json:"name"`
	Description    string `db:"description" json:"description"`
	ScopeCreatedAt string `db:"scope_created_at" json:"created_at"`
	Active         bool   `db:"active" json:"active"`
	ScopeSlug      string `db:"scope_slug" json:"slug,omitempty"`
}

// ClientService is a model for client-scopes cmds received by the client handler
type ClientScopesCmd struct {
	ClientSlug string   `json:"client_slug"`
	ScopeSlugs []string `json:"scope_slugs"` // uuids of the scope slugs => for lookup
}

// ValidateCmd performs input validation check on client scopes fields.
func (c *ClientScopesCmd) ValidateCmd() error {

	if !validate.IsValidUuid(c.ClientSlug) {
		return fmt.Errorf("invalid client slug")
	}

	if len(c.ScopeSlugs) > 0 {
		for _, slug := range c.ScopeSlugs {
			if !validate.IsValidUuid(slug) {
				return fmt.Errorf("invalid scope slug submitted: all slugs must be valid uuids")
			}
		}
	}

	return nil
}

// ClientScopeXref is a model for a many-to-many xref table holding clients <--> scopes
type ClientScopeXref struct {
	ClientId  string          `db:"client_uuid"`
	ScopeId   string          `db:"scope_uuid"`
	CreatedAt data.CustomTime `db:"created_at"`
}
